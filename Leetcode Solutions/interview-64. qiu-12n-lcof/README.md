## 题目描述

求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

## 解法
sum = n * (n + 1) / 2
实际上就是n和(n + 1)每一位mask以后再加入sum中，最后右移一位。
如果b的最低位为 0，则mask = 0x00000000;
如果b的最低位为 1，则mask = 0xffffffff;
因此 mask = ~(b & 1) + 1;
或者 mask = !(b & 1) - 1; （两种方法都行）
之后逐位左移a、右移b，再加入sum中就行了。
n <= 10000，所以最多只会有14个bit，干脆就循环15次算了。

## 代码

```cpp
class Solution {
public:
    int sumNums(int n) {
        int sum = 0, a = n, b = n + 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;

        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;

        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        a <<= 1; b >>= 1;
        sum += a & (~(b & 1) + 1);
        return sum >> 1;
    }
};
```